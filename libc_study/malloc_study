# Ptmalloc 源码学习 #
**注：在不经过特殊说明的情况下，以下研究结果均针对64-bit操作系统。**
## malloc.c ##
### unlink宏 ###
unlink()为双向链表的拆链函数，在ptmalloc中以宏的形式进行了定义，其具体定义如下所示：  
![unlink](https://raw.githubusercontent.com/fade-vivida/libc-linux-source-code-study/master/libc_study/picture/unlink.PNG)  
首先对要进行拆链的堆块P进行一系列的安全检查。
#### 1）check 1 ####
检查表达式：

    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))  \
      malloc_printerr ("corrupted size vs. prev_size");			  \
check当前拆链的chunk_p的size字段，是否和下一个chunk的presize字段相等。其中\_\_builtin\_expect是GNU C特有的编译器的优化用法，作用为假设其第一个参数（或者是表达式的值）很大可能上与第二个参数相等，目的是为了加快流水线的执行速度。  

对应错误信息：  
![error1](https://raw.githubusercontent.com/fade-vivida/libc-linux-source-code-study/master/libc_study/picture/error1.PNG)
#### 2）check 2 ####
    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))		  \
      malloc_printerr ("corrupted double-linked list");			  \
经典的双向链表拆链前的验证操作，查看  
FD->bk == chunk\_P?  
BK->fd == chunk\_P?  
其中FD = chunk\_P->fd，BK = chunk\_P->bk  
对应错误信息：  
![error2](https://raw.githubusercontent.com/fade-vivida/libc-linux-source-code-study/master/libc_study/picture/error2.PNG)
#### 3）check 3 ####
检查当前chunk的size是否在smallbin的范围内，在64-bit下samllbin的大小最大为512byte。如果chunk\_size>512，则该chunk属于largebin，判断其fd\_nextsize字段是否为NULL（其中fd\_nextsize和bk\_nextsize字段是largebin特有的）。

    if (!in_smallbin_range (chunksize_nomask (P))			 \
    && __builtin_expect (P->fd_nextsize != NULL, 0)) {		  \
    	if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)	  \
    		|| __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))\
    	  malloc_printerr ("corrupted double-linked list (not small)");   \
若fd\_nextsize字段不为NULL，则判断largebin的双向链表是否完整（判断方法与smallbin相同，即chunk\_P->fd\_nextsize->bk\_nextsize == chunk\_P? &&  
chunk\_P->bk\_nextsize->fd\_nextsize == chunk\_P?)  
对应错误信息：  
![error3](https://raw.githubusercontent.com/fade-vivida/libc-linux-source-code-study/master/libc_study/picture/error3.PNG)
#### 4）unlink操作 ####
完成这一系列check后，则进行双向链表的拆链操作。  
##### 4.1 chunk大小为smallbin #####
经典的拆链操作（其中FD = chunk\_P->fd，BK = chunk\_P->bk）：  
FD->bk = BK  
BK->fd = FD  
##### 4.2 chunk大小为largebin #####
    if (FD->fd_nextsize == NULL) {				  \
    	if (P->fd_nextsize == P)				  \
      		FD->fd_nextsize = FD->bk_nextsize = FD;		  \
    	else {							  \
    		FD->fd_nextsize = P->fd_nextsize;			  \
    		FD->bk_nextsize = P->bk_nextsize;			  \
    		P->fd_nextsize->bk_nextsize = FD;			  \
    		P->bk_nextsize->fd_nextsize = FD;			  \
      	}							  \
    } 
	else {							  \
    	P->fd_nextsize->bk_nextsize = P->bk_nextsize;		  \
    	P->bk_nextsize->fd_nextsize = P->fd_nextsize;		  \
	}								  \

动态调试结果：  
![largebin](https://raw.githubusercontent.com/fade-vivida/libc-linux-source-code-study/master/libc_study/picture/largebin.PNG)  
疑惑点：关于fd\_nextsize和bk\_nextsize字段的作用。  
首先判断fd，bk构成的双向链表中的前一个chunk是否为largebin，然后判断当前chunk的fd\_nextsize字段是否指向自身。若是，表明当前chunk是第一个largebin chunk


# \_int\_malloc(mstate av,size_t bytes) #
函数执行流程如下所示：  
Fastbin

# Fastbin分配机制 #
## 1. 调用checked\_request2size(bytes,nb)得到真正的chunk大小 ##
其中req为用户请求申请的chunk大小（也即用户可输入的数据大小），sz为进行规范化后chunk的实际大小（即malloc\_chunk中的size字段），其中REQUEST\_OUT\_OF\_RANGE宏定义为

    #define REQUEST_OUT_OF_RANGE(req) ((unsigned long) (req) >= (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))
	//计算得到可申请的最大堆块大小为0xFFFFFFC0（即3.9G）     
![request2size](https://raw.githubusercontent.com/fade-vivida/libc-linux-source-code-study/master/libc_study/picture/checked_request2size.PNG)  
可以看到，在check_request2size()中，又继续调用request2size()来得到实际chunk的size。  
request2size()的实现代码如下所示：  

    #define request2size(req) \
      (((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ? \
       MINSIZE :  \
       ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)
其中MINSIZE定义如下：

    #define MINSIZE  \
      (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK))
	  //其中 MALLOC_ALIGN_MASK = MALLOC_ALIGNMENT - 1，MALLOC_ALIGNMENT定义如下，反推可以得到MALLOC_ALIGN_MASK=0xF
	
	#define MALLOC_ALIGNMENT = (2*SIZE_T < __alignof__(long double) ? __alignof__(long double):(2*SIZE_T)
	//__alignof__为一个宏定义，即得到对应数据类型的对齐值，在64-bit下__alignof__(long double)=16，也即MALLOC_ALIGNMENT=0x10
  
MIN\_CHUNK\_SIZE定义为：

    #define MIN_CHUNK_SIZE(offsetof(struct malloc_chunk, fd_nextsize))
	//其中offsetof为一个宏定义，功能为计算得到fd_nextsize在malloc\_chunk结构体中的偏移（即宏定义返回值为0x20，64-bit）。
	//因此我们从这可以看出对于ptmalloc机制而言，最小分配的chunk大小为0x20（32-bit下最小chunk大小为0x10）。 
反推回去得知，MINSIZE = (0x20 + 0xF) & 0xFFFFFFF0 = 0x20 （64-bits），32位下MINSZIE按照同样的计算方法为0x10。  
至此，我们得到了request2size(req)函数的计算方法，代码如下所示：

    if(req + 8 + 0xf < 0x20)
		return 0x20;
	else
		return (req + 0x8 + 0xf) & 0xfffffff0		//增加8byte字节后，对于16byte进行取整
**注：从这我们可以得到在ptmalloc机制中堆块重叠使用的根本原理所在，即如果当前堆块不为空，下一个堆块的presize字段可被当前堆块作为数据区使用。**
## 2.计算得到fastbin数组索引，进行拆链操作 ##
首先查看当前arena是否可用（多线程下除main\_arnea外，还存在其他arnea，具体数目为处理器内核数*2+1)，其中\_\_glibc\_unlikely宏实际调用的还是\_\_builtin\_expect()宏，功能为进行编译器优化，将最可能的执行结构放在跳转指令后，加大分支预测的成功率。这里\_\_glibc\_unlikely就为之后表达式不成功的概率较大。

    /* There are no usable arenas.  Fall back to sysmalloc to get a chunk from
     mmap.  */
      if (__glibc_unlikely (av == NULL))
    {
      void *p = sysmalloc (nb, av);
      if (p != NULL)
    	alloc_perturb (p, bytes);
      return p;
    }
然后判断当前申请chunk size(nb)是否满足fastbin大小，其中get_max_fast()函数在32-bit下返回值为0x50，在64-bit为下返回值为0xa0。

    if ((unsigned long) (nb) <= (unsigned long) (get_max_fast ())) //get max_size of fastbin:80(0x50,32-bit),160byte(0xa0,64-bit)
	{
		idx = fastbin_index (nb);
		mfastbinptr *fb = &fastbin (av, idx);
      	mchunkptr pp;
      	victim = *fb;
然后使用fastbin\_index计算当前chunk size所属的fastbin数组的索引，计算方法如下：
    
	#define fastbin_index(sz) ((((unsigned int) (sz)) >> (SIZE_SZ == 8 ? 4 : 3)) - 2)
由于计算结果采用了不精确的计算方法，这其实就是为什么可以利用fastbin attack攻击的原理所在。  
然后调用fastbin(av,idx)宏，得到当前chunk size所属fastbin数组元素的地址（fb），victim就为fastbin[idx]链表中第一个chunk节点。其中fastbin宏定义如下：

    #define fastbin(ar_ptr, idx) ((ar_ptr)->fastbinsY[idx])
如果victime==NULL，表明当前fastbin链表为空，则无法使用fastbin进行分配，需要采用后续解决方法。如果victim!=NULL，首先判断当前程序是否为单线程。若是，取出fastbin链表中的第一个元素，也即最后加入的元素（因此，fastbi链表采用先进后出FILO原则)

	if (victim != NULL)
	{
		if (SINGLE_THREAD_P)
			*fb = victim->fd;
			//FILO
	  	else
			REMOVE_FB (fb, pp, victim);
				
如过当前程序为多线程，则使用REMOVE_FB宏进行fastbin链表的拆链操作。具体操作如下所示： 

    #define REMOVE_FB(fb, victim, pp)			
	do							
    {
		victim = pp;					
		if (victim == NULL)				
    		break;						
    }							
    while ((pp = catomic_compare_and_exchange_val_acq (fb, victim->fd, victim))!= victim);					
其中catomic\_compare\_and\_exchange\_val\_acq(mem,new\_val,old\_val)为一个原子比较交换操作，具体含义如下：
    
	if(*mem == old_val){
		*mem = new_val;
	}
	//返回值为new_val
**疑惑点：多线程下的REMOVE\_FB操作是要讲所有的fastbin都从链表中拆除？**


	if (__glibc_likely (victim != NULL))
    {
		size_t victim_idx = fastbin_index (chunksize (victim));
		//#define chunksize(p) (chunksize_nomask (p) & ~(SIZE_BITS))
		if (__builtin_expect (victim_idx != idx, 0))
    		malloc_printerr ("malloc(): memory corruption (fast)");
		check_remalloced_chunk (av, victim, nb);
然后调用chunksize()得到当前从fastbin链表中取下的victim chunk的大小，并计算得到其所属的fastbin数组的索引值（victim_idx)，并与当前该chunk所在的fastbin数组的索引下标作比较，看是否相等。  

**注：这里引入了很重要的一点，即为什么我们在采用fastbin attack时，需要将fd指向一个符合当前fastbinY[idx]数组大小的位置（可以错位，且比较时是将size转化为一个unsigned int（32-bit））**


## 3.对从fastbin数组链表中获取到的victim，进行更为严格的检查 ##
在对victim的size字段进行检查后，又调用了check\_remalloced\_chunk()对victim进行了更为细致的检查。check\_remalloced_chunk()函数的定义如下所示：

    do_check_remalloced_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T s)
    {
		INTERNAL_SIZE_T sz = chunksize_nomask (p) & ~(PREV_INUSE | NON_MAIN_ARENA);
		//去除PREV_INUSE和NON_MAIN_ARENA字段
		if (!chunk_is_mmapped (p))
    	{
			//如果该chunk不是mmap分配，而是调用brk分配的。
			assert (av == arena_for_chunk (p));
			//调用arena_for_chunk宏，根据当前chunk的地址及size字段得到其所属的arnea
			//arena_for_chunk(p)，如果p->size & NON_MAIN_ARENA == 0,则返回&main_arean
			//否则返回(p&(~(0x400*0x400-1)))->ar_ptr字段
      		if (chunk_main_arena (p))
    			assert (av == &main_arena);
      		else
    			assert (av != &main_arena);
    	}
    	do_check_inuse_chunk (av, p);
    	/* Legal size ... */
      	assert ((sz & MALLOC_ALIGN_MASK) == 0);
      	assert ((unsigned long) (sz) >= MINSIZE);
      	/* ... and alignment */
      	assert (aligned_OK (chunk2mem (p)));
      	/* chunk is less than MINSIZE more than request */
      	assert ((long) (sz) - (long) (s) >= 0);
      	assert ((long) (sz) - (long) (s + MINSIZE) < 0);
    } 
函数功能大体分析如下：  
1. 检查该chunk所在的arena是否与之前传入函数的av相等。**（注意点：使用fastbin attack攻击时，在构造伪chunk时，其size字段的IS_MAPPED(0x2)必须为1，这样才能绕过对于arean的检查）**  
2. 调用do\_check\_inuse\_chunk(av,p)，在do\_check\_inuse\_chunk()函数中，还会调用do\_check\_chunk()函数首先对victim块进行相关检查，然后检查下一个chunk的PRE\_INUSE是否置1（fastbin不合并，因此与其相邻的下一个chunk的PRE\_INUSE字段永远为1）；并检查当前chunk的相邻chunk是否处于free状态，如果是，调用do\_check\_free\_chunk对其进行检查。  
3. 对申请chunk的大小进行检查，对victim的地址进行对齐检查。

对取下的victim chunk进行检查后，是一些关于TCACHE机制的使用方法，具体会在之后的文章中进行分析。

	#if USE_TCACHE
	/* While we're here, if we see other chunks of the same size, stash them in the tcache.  */
	size_t tc_idx = csize2tidx (nb);
	if (tcache && tc_idx < mp_.tcache_bins)
	{
		mchunkptr tc_victim;
		/* While bin not empty and tcache not full, copy chunks.  */
  		while (tcache->counts[tc_idx] < mp_.tcache_count
	 		&& (tc_victim = *fb) != NULL)
		{
  			if (SINGLE_THREAD_P)
				*fb = tc_victim->fd;
  			else
			{
	  			REMOVE_FB (fb, pp, tc_victim);
	  			if (__glibc_unlikely (tc_victim == NULL))
					break;
			}
  			tcache_put (tc_victim, tc_idx);
		}
	}
	#endif
TCACHE机制后，如果设置了perturb\_byte，则调用alloc\_pertrub对chunk的数据区进行填充。

	void *p = chunk2mem (victim);
	alloc_perturb (p, bytes);
	return p;
	}}}
alloc\_perturb()函数定义如下：

    static void alloc_perturb (char *p, size_t n)
    {
		if (__glibc_unlikely (perturb_byte))
    	memset (p, perturb_byte ^ 0xff, n);
    }
至此，在\_int\_malloc()函数中fastbin部分的分析结束。

# SmallBin分配机制 #

	#define NSMALLBINS 64
    #define SMALLBIN_WIDTHMALLOC_ALIGNMENT
    #define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > 2 * SIZE_SZ)
    #define MIN_LARGE_SIZE((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)
    #define in_smallbin_range(sz) ((unsigned long) (sz) < (unsigned long) MIN_LARGE_SIZE)


	if (in_smallbin_range (nb))
    {	
		idx = smallbin_index (nb);
      	bin = bin_at (av, idx);
    	if ((victim = last (bin)) != bin)
    	{
      		bck = victim->bk;
    	  	if (__glibc_unlikely (bck->fd != victim))
    			malloc_printerr ("malloc(): smallbin double linked list corrupted");
      		set_inuse_bit_at_offset (victim, nb);
      		bin->bk = bck;
      		bck->fd = bin;
    		if (av != &main_arena)
    			set_non_main_arena (victim);
      		check_malloced_chunk (av, victim, nb);
首先调用in\_smallbin\_range宏检查申请size是否在smallbin范围内（64-bit:1024byte      32-bit:512byte）。然后计算得到所属smallbin的索引号，计算方法如下所示（即在64-bit下，idx=size/16；32-bit下，idx=size/8+SMALLBIN_CORRECTION）：

    #define smallbin_index(sz) ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) >> 4) : (((unsigned) (sz)) >> 3)) + SMALLBIN_CORRECTION)
然后根据索引号idx，计算得到该bin数组的地址。

    #define bin_at(m, i) \
      (mbinptr) (((char *) &((m)->bins[((i) - 1) * 2]))			  \
     - offsetof (struct malloc_chunk, fd))
    //之所以要减去0x10，是因为smallbin是以双向链表的形式存在，fd指针在malloc_chunk结构中的偏移就是0x10
	//因此如果把bin数组也当做一个malloc_chunk结构的话，则该chunk的地址就为fd指针地址减去0x10。
然后调用last(bin)检查当前bin链表中是否存在空闲的chunk。如果存在，取下最先放入该链表的chunk（FIFO，先入先出规则），并对链表的完整新进行检验（victim->bk->fd==victim?）。如果链表被破坏，打印出错误信息。  
![smallbin double linked list corrupted](https://raw.githubusercontent.com/fade-vivida/libc-linux-source-code-study/master/libc_study/picture/small_double_linklist_corrupt.PNG)  
然后调用set\_inuse\_bit\_at\_offset()函数，标志当前chunk已被使用。

    #define set_inuse_bit_at_offset(p, s) (((mchunkptr) (((char *) (p)) + (s)))->mchunk_size |= PREV_INUSE)
然后进行双向链表的拆链操作  
bin->bk=bck  
bck->fd=bin  
如果当前arena不是main\_arena，则设置victim的NON\_MAIN_ARENA位。然后调用check\_malloced\_chunk()对victim进行一系列检查。